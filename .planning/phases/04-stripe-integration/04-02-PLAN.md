---
phase: 04-stripe-integration
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - src/app/api/webhooks/stripe/route.ts
autonomous: true
requirements:
  - PAY-04
  - PAY-05
  - PAY-06
  - PAY-07
  - PAY-08
  - PAY-09
  - PAY-10
  - PAY-13
  - PAY-14
  - CRED-02
  - CRED-04
  - CRED-09

must_haves:
  truths:
    - "Stripe webhook verifies signatures and rejects invalid requests with 400"
    - "Duplicate events are detected and skipped (idempotent processing)"
    - "customer.subscription.created/updated upserts subscription record in database"
    - "customer.subscription.deleted marks subscription as canceled"
    - "invoice.paid allocates 10 credits via credit_transactions ledger insert"
    - "invoice.paid uses invoice.id as billing_period_id to prevent double credit allocation"
    - "invoice.payment_failed marks subscription as past_due without touching credits"
    - "Webhook returns 200 for all processed events including errors (prevents Stripe retry loop)"
  artifacts:
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler with signature verification, idempotency, and event routing"
      exports: ["POST"]
      min_lines: 100
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "stripe.webhooks.constructEvent"
      via: "SDK signature verification"
      pattern: "stripe\\.webhooks\\.constructEvent"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "stripe_processed_events"
      via: "idempotency check before processing"
      pattern: "stripe_processed_events"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "subscriptions"
      via: "upsert on subscription events"
      pattern: "from\\('subscriptions'\\)"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "credit_transactions"
      via: "INSERT 10 credits on invoice.paid"
      pattern: "from\\('credit_transactions'\\)"
---

<objective>
Build the Stripe webhook handler that processes subscription lifecycle events and allocates credits on payment.

Purpose: This is the central integration point — Stripe sends events here when subscriptions are created, updated, canceled, or when invoices are paid/failed. The handler must be idempotent (Stripe retries for 3 days) and verify signatures to prevent spoofing.
Output: Single route handler file that handles 5 Stripe event types with idempotent processing
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-stripe-integration/04-RESEARCH.md
@.planning/phases/04-stripe-integration/04-01-SUMMARY.md
@src/app/api/webhooks/n8n/callback/route.ts
@src/lib/stripe/client.ts
@supabase/migrations/20260225_stripe_integration.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe webhook route handler with signature verification and idempotency</name>
  <files>
    src/app/api/webhooks/stripe/route.ts
  </files>
  <action>
    Create `src/app/api/webhooks/stripe/route.ts` following the exact same raw-body pattern as the existing N8N webhook handler (`src/app/api/webhooks/n8n/callback/route.ts`).

    **Structure:**

    1. **Imports:** NextRequest, NextResponse from 'next/server'; headers from 'next/headers'; stripe from '@/lib/stripe/client'; createClient from '@supabase/supabase-js'; Stripe type import for type assertions.

    2. **POST handler:**
       a. Read raw body via `request.text()` (CRITICAL: same pattern as N8N handler — must be text for signature verification)
       b. Get `stripe-signature` header via `(await headers()).get('stripe-signature')`
       c. Call `stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK_SECRET!)` in try/catch — return 400 on failure
       d. Create Supabase admin client with service role key (same pattern as N8N handler: `createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!)`)
       e. **Idempotency check:** Query `stripe_processed_events` for `event.id`. If found, return `{ received: true, duplicate: true }` with 200.
       f. **Record event:** Insert into `stripe_processed_events` with `stripe_event_id: event.id, event_type: event.type` BEFORE processing (crash safety)
       g. **Route events** in try/catch:
          - `customer.subscription.created` and `customer.subscription.updated` -> `handleSubscriptionUpsert()`
          - `customer.subscription.deleted` -> `handleSubscriptionDeleted()`
          - `invoice.paid` -> `handleInvoicePaid()`
          - `invoice.payment_failed` -> `handleInvoicePaymentFailed()`
       h. On handler error: log error, do NOT return 500 (event is already marked processed; returning 500 would cause Stripe to retry but idempotency would skip it — creates confusion). Return 200 and log for manual review.
       i. Return `{ received: true }` with 200.

    3. **handleSubscriptionUpsert(supabaseAdmin, subscription: Stripe.Subscription):**
       - Extract `user_id` from `subscription.metadata.user_id`
       - If no user_id, log error and return early
       - Upsert into `subscriptions` table with `onConflict: 'stripe_subscription_id'`:
         - user_id, stripe_subscription_id: subscription.id, stripe_customer_id: subscription.customer as string
         - stripe_price_id: subscription.items.data[0].price.id
         - status: subscription.status
         - current_period_start/end: Convert from Unix timestamp (subscription.current_period_start * 1000) to ISO string
         - cancel_at_period_end: subscription.cancel_at_period_end
         - canceled_at: Convert if exists, else null

    4. **handleSubscriptionDeleted(supabaseAdmin, subscription: Stripe.Subscription):**
       - Update subscriptions set status='canceled', canceled_at=NOW() where stripe_subscription_id = subscription.id

    5. **handleInvoicePaid(supabaseAdmin, invoice: Stripe.Invoice):**
       - If `!invoice.subscription` return (skip non-subscription invoices)
       - **Double-safety credit idempotency (CRED-09):** Query credit_transactions for type='monthly_allocation' with metadata containing invoice_id = invoice.id. If found, return (already allocated).
       - Find user_id from subscriptions table via stripe_subscription_id = invoice.subscription
       - If no user found, log error and return
       - Insert credit_transaction: amount=10, type='monthly_allocation', metadata={ invoice_id: invoice.id, billing_period_start: invoice.period_start, billing_period_end: invoice.period_end, stripe_subscription_id: invoice.subscription }

    6. **handleInvoicePaymentFailed(supabaseAdmin, invoice: Stripe.Invoice):**
       - If `!invoice.subscription` return
       - Update subscriptions set status='past_due' where stripe_subscription_id = invoice.subscription
       - Do NOT touch credit_transactions (PAY-14)

    **Important notes:**
    - Use `import type Stripe from 'stripe'` for type-only imports where appropriate
    - The `SupabaseClient` type for the admin client parameter should be imported from `@supabase/supabase-js`
    - All console.log/error should use `[Stripe Webhook]` prefix for log filtering
    - The `invoice.subscription` field can be string | Stripe.Subscription | null — cast to string with `as string` when used as a filter value
  </action>
  <verify>
    - File compiles: `npx tsc --noEmit src/app/api/webhooks/stripe/route.ts`
    - Exports POST function
    - Contains `stripe.webhooks.constructEvent` call
    - Contains idempotency check against `stripe_processed_events`
    - Contains all 4 handler functions
    - Contains credit_transactions INSERT with amount: 10 in handleInvoicePaid
    - `npm run build` passes (full build check)
  </verify>
  <done>
    Stripe webhook handler processes 5 event types with signature verification, idempotency at both event and credit level, and proper error handling that returns 200 to prevent Stripe retry loops
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes with webhook route included
- Webhook handler has signature verification (constructEvent)
- Idempotency: stripe_processed_events checked before processing
- Credit idempotency: invoice_id checked in credit_transactions metadata before allocating
- All 5 event types handled: subscription.created, .updated, .deleted, invoice.paid, invoice.payment_failed
- No credits touched on payment failure (PAY-14)
- Handler returns 200 even on processing errors
</verification>

<success_criteria>
- Webhook route handler compiles and builds successfully
- Signature verification rejects invalid payloads
- Duplicate events are idempotently skipped
- invoice.paid allocates exactly 10 credits with invoice_id metadata
- Subscription lifecycle events correctly upsert/update/cancel subscription records
- Failed payments mark subscription past_due without touching credits
</success_criteria>

<output>
After completion, create `.planning/phases/04-stripe-integration/04-02-SUMMARY.md`
</output>
