---
phase: 02-brand-management
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/validations/brand.ts
  - src/app/(dashboard)/brand/actions.ts
  - src/app/(dashboard)/brand/page.tsx
  - src/app/(dashboard)/brand/brand-settings-form.tsx
  - src/lib/brand/check-completion.ts
  - src/app/(dashboard)/dashboard/page.tsx
autonomous: true
requirements: [BRND-01, BRND-02, BRND-03]

must_haves:
  truths:
    - "User can view brand settings form with current values pre-filled"
    - "User can edit all brand fields (name, colors, voice, product, audience, CTA)"
    - "User can save brand settings and changes persist to database"
    - "Dashboard prompts user to complete brand profile if still using defaults"
    - "Form validation prevents invalid data (empty fields, malformed colors)"
  artifacts:
    - path: "src/lib/validations/brand.ts"
      provides: "Zod schema for brand profile validation"
      exports: ["BrandProfileSchema", "BrandProfile"]
    - path: "src/app/(dashboard)/brand/actions.ts"
      provides: "Server Action for saving brand profile"
      exports: ["saveBrandProfile"]
    - path: "src/app/(dashboard)/brand/page.tsx"
      provides: "Brand settings page (Server Component)"
      min_lines: 30
    - path: "src/app/(dashboard)/brand/brand-settings-form.tsx"
      provides: "Brand settings form (Client Component)"
      min_lines: 80
    - path: "src/lib/brand/check-completion.ts"
      provides: "Utility to check if brand profile is complete"
      exports: ["checkBrandProfileComplete"]
    - path: "src/app/(dashboard)/dashboard/page.tsx"
      provides: "Dashboard with brand completion prompt"
      contains: "Complete Brand Profile"
  key_links:
    - from: "src/app/(dashboard)/brand/brand-settings-form.tsx"
      to: "src/app/(dashboard)/brand/actions.ts"
      via: "useActionState with saveBrandProfile"
      pattern: "useActionState.*saveBrandProfile"
    - from: "src/app/(dashboard)/brand/actions.ts"
      to: "brand_profiles table"
      via: "Supabase upsert with onConflict: 'user_id'"
      pattern: "upsert.*onConflict.*user_id"
    - from: "src/app/(dashboard)/dashboard/page.tsx"
      to: "src/lib/brand/check-completion.ts"
      via: "Server Component checks completion state"
      pattern: "checkBrandProfileComplete"
---

<objective>
Build brand settings UI with form validation, upsert-based persistence, and dashboard integration to prompt profile completion.

Purpose: Enable users to customize their brand identity (colors, voice, messaging) required for personalized carousel generation. Dashboard guides users to complete profile before attempting first generation.

Output: Complete brand management UI with Zod validation, Server Actions, and completion checking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-brand-management/02-RESEARCH.md
@.planning/phases/02-brand-management/02-01-SUMMARY.md

# Phase 1 patterns to follow
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@src/lib/supabase/server.ts
@src/app/(dashboard)/dashboard/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Create Zod validation schema and Server Action</name>
  <files>
src/lib/validations/brand.ts
src/app/(dashboard)/brand/actions.ts
  </files>
  <action>
Create brand profile validation and save logic following patterns from 02-RESEARCH.md.

**File 1: src/lib/validations/brand.ts**

Create Zod schema exactly as shown in 02-RESEARCH.md "Pattern 4: Zod Schema for Type-Safe Validation":
- BrandProfileSchema with fields: brandName, primaryColor, secondaryColor, voiceGuidelines, productDescription, targetAudience, ctaText
- String length validation: brandName (2-50), voiceGuidelines (10-500), productDescription (10-500), targetAudience (10-200), ctaText (2-30)
- Regex validation for colors: `/^#[0-9A-Fa-f]{6}$/` with specific error messages
- Export type: `export type BrandProfile = z.infer<typeof BrandProfileSchema>`

**File 2: src/app/(dashboard)/brand/actions.ts**

Implement Server Action following exact pattern from 02-RESEARCH.md "Save Brand Profile Server Action":
```typescript
'use server'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'
import { BrandProfileSchema } from '@/lib/validations/brand'

export async function saveBrandProfile(prevState: any, formData: FormData) {
  // 1. Validate with Zod (safeParse, return errors if invalid)
  // 2. Get authenticated user via supabase.auth.getUser()
  // 3. Upsert to brand_profiles with onConflict: 'user_id' (CRITICAL)
  // 4. If error, return { message: 'Failed to save...' }
  // 5. revalidatePath('/dashboard') and revalidatePath('/brand')
  // 6. redirect('/dashboard') OUTSIDE try/catch (see Pitfall 7)
}
```

**Critical patterns:**
- Use `onConflict: 'user_id'` NOT primary key (see 02-RESEARCH.md "Pitfall 6")
- Call redirect() outside try/catch (see 02-RESEARCH.md "Pitfall 7")
- Map FormData fields to snake_case database columns: brandName → brand_name
- Return validation errors in format: `{ errors: validatedFields.error.flatten().fieldErrors }`

**Why upsert (not insert/update):**
Per 02-RESEARCH.md "Don't Hand-Roll": Upsert is atomic, prevents race conditions, handles both first-time save and subsequent edits without conditional logic.
  </action>
  <verify>
1. Zod schema exists: `grep -q "BrandProfileSchema" src/lib/validations/brand.ts`
2. Regex validation for colors: `grep -q "regex.*#\[0-9A-Fa-f\]" src/lib/validations/brand.ts`
3. Server Action exists: `grep -q "'use server'" src/app/(dashboard)/brand/actions.ts`
4. Upsert with onConflict: `grep -q "onConflict.*user_id" src/app/(dashboard)/brand/actions.ts`
5. Redirect outside try/catch: Verify redirect() is not inside catch block
6. TypeScript compilation: `npx tsc --noEmit`
  </verify>
  <done>
Zod schema validates all brand fields with length and format constraints. Server Action performs authenticated upsert with onConflict: 'user_id', revalidates paths, and redirects to dashboard. No validation errors on compilation.
  </done>
</task>

<task type="auto">
  <name>Build brand settings form UI</name>
  <files>
src/app/(dashboard)/brand/page.tsx
src/app/(dashboard)/brand/brand-settings-form.tsx
  </files>
  <action>
Create brand settings page and form component following 02-RESEARCH.md patterns.

**File 1: src/app/(dashboard)/brand/page.tsx (Server Component)**

Server Component that fetches brand profile and renders form:
```typescript
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import { BrandSettingsForm } from './brand-settings-form'

export default async function BrandPage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) redirect('/login')

  // Fetch brand profile using .single() (expect exactly one row due to 1:1 relationship)
  const { data: profile, error } = await supabase
    .from('brand_profiles')
    .select('*')
    .eq('user_id', user.id)
    .single()

  if (error) {
    return <div>Error loading brand settings. Please try refreshing.</div>
  }

  return (
    <div>
      <h1>Brand Settings</h1>
      <BrandSettingsForm initialData={{ /* map to camelCase */ }} />
    </div>
  )
}
```

**File 2: src/app/(dashboard)/brand/brand-settings-form.tsx (Client Component)**

Implement form exactly as shown in 02-RESEARCH.md "Brand Settings Form (Client Component)":
- Use `'use client'` directive
- Import useActionState from 'react' (not useFormState - see 02-RESEARCH.md "State of the Art")
- Form fields: brandName (text), primaryColor (color), secondaryColor (color), voiceGuidelines (textarea), productDescription (textarea), targetAudience (textarea), ctaText (text)
- Use HTML5 `<input type="color">` for color pickers (no external library - see 02-RESEARCH.md "Don't Hand-Roll")
- Display validation errors from state.errors for each field
- Show isPending state on submit button: "Saving..." vs "Save Brand Settings"
- Set defaultValue from initialData props

**Critical patterns:**
- useActionState signature: `useActionState<FormState, FormData>(saveBrandProfile, {})`
- Error display: `{state.errors?.brandName && <p className="text-red-500">{state.errors.brandName[0]}</p>}`
- Native color input returns lowercase #rrggbb format automatically (no conversion needed)

**Why native color input (not react-colorful):**
Per 02-RESEARCH.md "Standard Stack": HTML5 color input has universal browser support in 2026, returns validated hex format, zero dependencies. External library adds 2.8KB for minimal UX improvement.
  </action>
  <verify>
1. Server Component fetches profile: `grep -q "supabase.*from.*brand_profiles" src/app/(dashboard)/brand/page.tsx`
2. Client Component uses useActionState: `grep -q "useActionState" src/app/(dashboard)/brand/brand-settings-form.tsx`
3. Color inputs use native type: `grep -q 'type="color"' src/app/(dashboard)/brand/brand-settings-form.tsx`
4. Textarea for long text fields: `grep -q "<textarea" src/app/(dashboard)/brand/brand-settings-form.tsx`
5. Error display for validation: `grep -q "state.errors" src/app/(dashboard)/brand/brand-settings-form.tsx`
6. TypeScript compilation: `npx tsc --noEmit`
7. Start dev server and visit /brand route (basic smoke test)
  </verify>
  <done>
Brand settings page fetches user's profile via RLS-protected query and passes to form. Client form component uses useActionState with Server Action, displays all 7 brand fields with validation errors, uses native HTML5 color inputs, and shows loading state during submission.
  </done>
</task>

<task type="auto">
  <name>Add brand completion check and dashboard prompt</name>
  <files>
src/lib/brand/check-completion.ts
src/app/(dashboard)/dashboard/page.tsx
  </files>
  <action>
Implement brand profile completion detection and integrate into dashboard.

**File 1: src/lib/brand/check-completion.ts**

Create utility following 02-RESEARCH.md "Check Brand Profile Completion" pattern:
```typescript
import { createClient } from '@/lib/supabase/server'

export async function checkBrandProfileComplete(): Promise<boolean> {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) return false

  // Use maybeSingle() not single() (see 02-RESEARCH.md "Pitfall 4")
  const { data: profile, error } = await supabase
    .from('brand_profiles')
    .select('brand_name, voice_guidelines, product_description')
    .eq('user_id', user.id)
    .maybeSingle()

  if (error || !profile) return false

  // Check if profile has been customized beyond defaults
  return (
    profile.brand_name !== 'My Brand' &&
    profile.voice_guidelines !== 'Professional and helpful' &&
    profile.product_description !== 'Enter your product description'
  )
}
```

**Why maybeSingle() not single():**
Per 02-RESEARCH.md "Pattern 3": single() throws 406 error when row doesn't exist. maybeSingle() gracefully returns null, avoiding extra error handling.

**File 2: src/app/(dashboard)/dashboard/page.tsx**

Modify existing dashboard page to check brand completion and show prompt if incomplete:
```typescript
import { checkBrandProfileComplete } from '@/lib/brand/check-completion'
import Link from 'next/link'

export default async function DashboardPage() {
  const isComplete = await checkBrandProfileComplete()

  return (
    <div>
      {!isComplete && (
        <div className="bg-yellow-50 border border-yellow-200 p-4 rounded mb-4">
          <h2 className="font-semibold">Complete Your Brand Profile</h2>
          <p>Set up your brand colors, voice, and messaging before generating carousels.</p>
          <Link href="/brand" className="text-blue-600 underline">
            Complete Brand Profile →
          </Link>
        </div>
      )}

      {/* Existing CreditBalance and other dashboard content */}
    </div>
  )
}
```

**Integration requirement:**
Per BRND-01: "User is prompted to create brand profile on first carousel generation attempt". Since Phase 3 (carousel generation) doesn't exist yet, we prompt on dashboard. In Phase 3, generation endpoint will check completion and block with same prompt.

**Why check defaults (not just existence):**
Trigger auto-creates profile for every user, so existence check would always pass. Must verify user has customized beyond placeholder values.
  </action>
  <verify>
1. Utility exists: `test -f src/lib/brand/check-completion.ts`
2. Uses maybeSingle: `grep -q "maybeSingle" src/lib/brand/check-completion.ts`
3. Checks default values: `grep -q "My Brand" src/lib/brand/check-completion.ts`
4. Dashboard imports utility: `grep -q "checkBrandProfileComplete" src/app/(dashboard)/dashboard/page.tsx`
5. Dashboard shows prompt: `grep -q "Complete Your Brand Profile" src/app/(dashboard)/dashboard/page.tsx`
6. Link to /brand: `grep -q 'href="/brand"' src/app/(dashboard)/dashboard/page.tsx`
7. TypeScript compilation: `npx tsc --noEmit`
  </verify>
  <done>
Brand completion utility checks if profile has been customized beyond defaults using maybeSingle(). Dashboard displays prominent prompt with link to /brand when profile is incomplete. Profile exists check validates customization, not just row existence.
  </done>
</task>

</tasks>

<verification>
1. **End-to-end flow:** User logs in → sees dashboard prompt → clicks "Complete Brand Profile" → fills form → saves → redirects to dashboard → prompt disappears
2. **Form validation:** Invalid hex color shows error, empty required field shows error, valid data saves successfully
3. **Upsert idempotency:** Saving twice with same data doesn't create duplicate rows (onConflict works)
4. **RLS enforcement:** User can only view/edit their own brand profile (verify by checking different user can't access)
5. **Type safety:** All database queries use generated types from 02-01-PLAN.md
6. **Default detection:** New user sees prompt, user with customized profile doesn't see prompt
</verification>

<success_criteria>
- User can navigate to /brand and see form pre-filled with current profile values
- User can edit all 7 brand fields (name, 2 colors, voice, product, audience, CTA)
- Form validation prevents invalid data (shows specific errors per field)
- Saving form upserts to database and redirects to dashboard
- Dashboard shows "Complete Brand Profile" prompt when profile uses default values
- Dashboard prompt disappears after user customizes brand settings
- All form interactions work without external dependencies (native HTML5 controls)
</success_criteria>

<output>
After completion, create `.planning/phases/02-brand-management/02-02-SUMMARY.md` documenting:
- Form architecture (Server Component + Client Component + Server Action pattern)
- Validation approach (Zod schema with field-level errors)
- Upsert pattern implementation
- Brand completion detection logic
- Dashboard integration approach
- Any UX decisions made (placeholder text, error messages, styling)
</output>
