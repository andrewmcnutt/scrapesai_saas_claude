---
phase: 02-brand-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260222_brand_profiles.sql
  - src/types/database.ts
autonomous: true
requirements: [BRND-04, BRND-05]

must_haves:
  truths:
    - "Every new user automatically has a brand_profiles record created on signup"
    - "User can only access their own brand profile (RLS enforced)"
    - "Brand profile user_id is unique (1:1 relationship with auth.users)"
  artifacts:
    - path: "supabase/migrations/20260222_brand_profiles.sql"
      provides: "Complete brand_profiles schema with RLS and triggers"
      contains: "CREATE TABLE brand_profiles"
    - path: "src/types/database.ts"
      provides: "TypeScript types for brand_profiles table"
      exports: ["Database"]
  key_links:
    - from: "auth.users"
      to: "brand_profiles"
      via: "database trigger on INSERT"
      pattern: "CREATE TRIGGER on_user_signup_create_brand"
    - from: "brand_profiles"
      to: "auth.users"
      via: "foreign key with CASCADE delete"
      pattern: "user_id UUID.*REFERENCES auth\\.users.*ON DELETE CASCADE"
---

<objective>
Create database foundation for brand management system with auto-created profiles, RLS security, and 1:1 user relationship.

Purpose: Establish the data model and security policies required for users to store and manage their brand settings. Every user automatically receives a brand profile with sensible defaults on signup.

Output: Database migration with brand_profiles table, RLS policies, trigger functions, and TypeScript types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-brand-management/02-RESEARCH.md

# Phase 1 established patterns
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md

# Reference existing migration for pattern
@supabase/migrations/20260222145815_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Create brand_profiles migration with RLS and triggers</name>
  <files>supabase/migrations/20260222_brand_profiles.sql</files>
  <action>
Create database migration file following exact schema from 02-RESEARCH.md "Recommended Database Schema" section.

**Schema requirements:**
- Table: brand_profiles with columns: id (UUID primary key), user_id (UUID UNIQUE FK to auth.users ON DELETE CASCADE), brand_name, primary_color, secondary_color, voice_guidelines, product_description, target_audience, cta_text, created_at, updated_at
- CHECK constraints on colors: `primary_color ~ '^#[0-9A-Fa-f]{6}$'` and `secondary_color ~ '^#[0-9A-Fa-f]{6}$'`
- Index on user_id for RLS policy performance (CRITICAL for preventing sequential scans)
- Enable RLS on table
- RLS policies: "Users can view own brand profile" (SELECT), "Users can insert own brand profile" (INSERT), "Users can update own brand profile" (UPDATE) - all using `(SELECT auth.uid()) = user_id` pattern
- Trigger function: create_brand_profile() with SECURITY DEFINER that INSERTs default profile on auth.users INSERT
- Trigger: on_user_signup_create_brand fires AFTER INSERT on auth.users
- Trigger function: update_updated_at_column() to auto-update updated_at timestamp
- Trigger: update_brand_profiles_updated_at fires BEFORE UPDATE

**Default values (per research):**
- brand_name: 'My Brand'
- primary_color: '#3B82F6' (blue)
- secondary_color: '#10B981' (green)
- voice_guidelines: 'Professional and helpful'
- product_description: 'Enter your product description'
- target_audience: 'Enter your target audience'
- cta_text: 'Learn More'

**Critical patterns from Phase 1:**
- Use same migration filename format: YYYYMMDD_description.sql
- Include comments explaining RLS policies and triggers
- Test for auth.uid() IS NOT NULL in policies (see 02-RESEARCH.md "Pitfall 3")

**Why auto-create via trigger (not frontend):**
Per 02-RESEARCH.md "Anti-Patterns to Avoid": Trigger ensures atomicity, can't be bypassed, runs with elevated privileges. Frontend approach adds complexity and failure modes.
  </action>
  <verify>
1. Migration file exists at `supabase/migrations/20260222_brand_profiles.sql`
2. File contains: CREATE TABLE, ALTER TABLE ENABLE ROW LEVEL SECURITY, CREATE POLICY (3 policies), CREATE FUNCTION (2 functions), CREATE TRIGGER (2 triggers), CREATE INDEX
3. Grep confirms trigger uses SECURITY DEFINER: `grep -q "SECURITY DEFINER" supabase/migrations/20260222_brand_profiles.sql`
4. Grep confirms index on user_id: `grep -q "CREATE INDEX.*brand_profiles.*user_id" supabase/migrations/20260222_brand_profiles.sql`
5. Grep confirms CHECK constraints on colors: `grep -q "CHECK.*primary_color.*#\[0-9A-Fa-f\]" supabase/migrations/20260222_brand_profiles.sql`
  </verify>
  <done>
Migration file created with complete schema including brand_profiles table, 3 RLS policies (SELECT/INSERT/UPDATE), 2 trigger functions (create_brand_profile + update_updated_at), 2 triggers, 1 index on user_id, and CHECK constraints on color format.
  </done>
</task>

<task type="auto">
  <name>Regenerate TypeScript database types</name>
  <files>src/types/database.ts</files>
  <action>
Update TypeScript types to include brand_profiles table schema.

**Steps:**
1. Apply migration locally: `npx supabase db reset` (applies all migrations including new one)
2. Regenerate types: `npx supabase gen types typescript --local > src/types/database.ts`
3. Verify brand_profiles appears in Database['public']['Tables'] type

**Expected structure:**
```typescript
brand_profiles: {
  Row: {
    id: string
    user_id: string
    brand_name: string
    primary_color: string
    secondary_color: string
    voice_guidelines: string
    product_description: string
    target_audience: string
    cta_text: string
    created_at: string
    updated_at: string
  }
  Insert: { /* omit id, created_at, updated_at (defaults) */ }
  Update: { /* all fields optional */ }
}
```

**Why regenerate (not hand-write):**
Per Phase 1 pattern established in 01-01-SUMMARY.md: Types are generated from actual schema to maintain type safety and prevent drift. Supabase CLI introspects database to produce accurate types.

**If Supabase not linked yet:**
Hand-create placeholder types matching migration schema (same approach as 01-01-PLAN.md Task 2). Types will be regenerated once Supabase project is linked.
  </action>
  <verify>
1. Types file updated: `git diff src/types/database.ts` shows brand_profiles type added
2. TypeScript compilation succeeds: `npx tsc --noEmit`
3. Grep confirms brand_profiles in types: `grep -q "brand_profiles" src/types/database.ts`
  </verify>
  <done>
src/types/database.ts includes brand_profiles table with Row, Insert, and Update types matching migration schema. TypeScript compilation passes with no errors.
  </done>
</task>

</tasks>

<verification>
1. **Migration completeness:** `cat supabase/migrations/20260222_brand_profiles.sql` contains all required SQL statements (table, RLS, triggers, index)
2. **RLS security:** Policies use `(SELECT auth.uid()) = user_id` pattern to prevent user_id spoofing
3. **Performance:** Index exists on user_id column for RLS policy efficiency
4. **Type safety:** brand_profiles type available in Database interface for type-safe queries
5. **Trigger atomicity:** create_brand_profile() uses SECURITY DEFINER and runs AFTER INSERT on auth.users
</verification>

<success_criteria>
- Migration file exists with complete schema (table + RLS + triggers + index)
- RLS policies enforce user isolation using auth.uid()
- Trigger auto-creates brand profile on user signup with default values
- Index on user_id prevents sequential scans when querying by owner
- TypeScript types include brand_profiles for type-safe database access
- Migration can be applied via `npx supabase db reset` without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-brand-management/02-01-SUMMARY.md` documenting:
- Schema structure and RLS policies created
- Trigger pattern for auto-creation
- Default values used
- Type generation approach
- Any deviations from research recommendations
</output>
