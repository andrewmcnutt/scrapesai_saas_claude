---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/middleware.ts
  - middleware.ts
  - src/app/(auth)/signup/page.tsx
  - src/app/(auth)/login/page.tsx
  - src/app/api/auth/signup/route.ts
  - src/app/api/auth/callback/route.ts
  - src/app/auth/callback/route.ts
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04

must_haves:
  truths:
    - "User can sign up with email and password"
    - "User receives email verification link after signup"
    - "User can verify email via link and gain access"
    - "User can log in with verified credentials"
    - "Session persists across browser refresh"
    - "User can log out and session is terminated"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser client for Client Components"
      exports: ["createClient"]
    - path: "src/lib/supabase/server.ts"
      provides: "Server client for Server Components/Actions"
      exports: ["createClient"]
    - path: "middleware.ts"
      provides: "Auth token refresh middleware"
      contains: "getClaims()"
    - path: "src/app/api/auth/signup/route.ts"
      provides: "Signup API endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/app/(auth)/signup/page.tsx"
      to: "/api/auth/signup"
      via: "form submission"
      pattern: "action.*api/auth/signup"
    - from: "src/app/api/auth/signup/route.ts"
      to: "supabase.auth.signUp"
      via: "createClient server call"
      pattern: "auth\\.signUp"
    - from: "middleware.ts"
      to: "supabase.auth.getClaims"
      via: "token validation"
      pattern: "auth\\.getClaims"
---

<objective>
Implement Supabase authentication with email verification flow, session management, and protected routes.

Purpose: Enable users to create accounts, verify emails, log in securely, and maintain authenticated sessions. This establishes the security foundation required before building credit system, brand management, and carousel generation features.

Output: Complete authentication system with signup, email verification, login, logout, session persistence via middleware token refresh, and route protection.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase Client Utilities</name>
  <files>
src/lib/supabase/client.ts
src/lib/supabase/server.ts
src/lib/supabase/middleware.ts
  </files>
  <action>
Create three Supabase client utilities following @supabase/ssr patterns from 01-RESEARCH.md Pattern 1:

**src/lib/supabase/client.ts** (for Client Components):
```typescript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

**src/lib/supabase/server.ts** (for Server Components and Actions):
```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Ignore: setAll called from Server Component
          }
        },
      },
    }
  )
}
```

**src/lib/supabase/middleware.ts** (for middleware-specific client):
```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let response = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))
          response = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            response.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // CRITICAL: Use getClaims() not getSession() for validation
  const { data } = await supabase.auth.getClaims()

  return { response, user: data }
}
```

These utilities follow the exact patterns from 01-RESEARCH.md to ensure proper cookie handling and token validation.
  </action>
  <verify>
Create temporary test file to verify clients:
```typescript
// test-clients.ts
import { createClient as createBrowserClient } from './src/lib/supabase/client'
import { createClient as createServerClient } from './src/lib/supabase/server'

console.log('Browser client:', typeof createBrowserClient())
console.log('Server client type check passed')
```

Run `npx tsx test-clients.ts` - should not throw errors
Delete test file after verification
  </verify>
  <done>
- Three Supabase client utilities exist (browser, server, middleware)
- Each uses correct @supabase/ssr import and pattern
- TypeScript compilation succeeds with no errors
- Clients use environment variables from .env.local
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Auth Middleware and Routes</name>
  <files>
middleware.ts
src/app/(auth)/signup/page.tsx
src/app/(auth)/login/page.tsx
src/app/api/auth/signup/route.ts
src/app/api/auth/callback/route.ts
src/app/auth/callback/route.ts
  </files>
  <action>
**Step 1: Create middleware.ts** (root directory) following 01-RESEARCH.md Pattern 2:
```typescript
import { type NextRequest } from 'next/server'
import { updateSession } from './src/lib/supabase/middleware'

export async function middleware(request: NextRequest) {
  const { response, user } = await updateSession(request)

  // Protect dashboard routes (future Phase 2+)
  const isProtectedRoute = request.nextUrl.pathname.startsWith('/dashboard')
  if (isProtectedRoute && !user) {
    const loginUrl = new URL('/login', request.url)
    loginUrl.searchParams.set('redirect', request.nextUrl.pathname)
    return NextResponse.redirect(loginUrl)
  }

  return response
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

**Step 2: Create signup API route** following 01-RESEARCH.md email verification example:
```typescript
// src/app/api/auth/signup/route.ts
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  const { email, password } = await request.json()
  const supabase = await createClient()

  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: `${request.nextUrl.origin}/auth/callback`,
    },
  })

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 400 })
  }

  return NextResponse.json({
    message: 'Check your email to confirm your account',
    user: data.user,
  })
}
```

**Step 3: Create email verification callback**:
```typescript
// src/app/auth/callback/route.ts
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const token_hash = searchParams.get('token_hash')
  const type = searchParams.get('type')

  if (token_hash && type === 'signup') {
    const supabase = await createClient()

    const { error } = await supabase.auth.verifyOtp({
      token_hash,
      type: 'signup',
    })

    if (!error) {
      // Allocate 3 free credits on signup verification
      const { data: { user } } = await supabase.auth.getUser()
      if (user) {
        await supabase.from('credit_transactions').insert({
          user_id: user.id,
          amount: 3,
          type: 'signup_bonus',
          metadata: { source: 'email_verification' }
        })
      }

      return NextResponse.redirect(new URL('/dashboard', request.url))
    }
  }

  return NextResponse.redirect(new URL('/login?error=verification_failed', request.url))
}
```

**Step 4: Create signup page** (simple form):
```typescript
// src/app/(auth)/signup/page.tsx
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'

export default function SignupPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')
  const [success, setSuccess] = useState(false)
  const router = useRouter()

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    setError('')

    const response = await fetch('/api/auth/signup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    const data = await response.json()

    if (response.ok) {
      setSuccess(true)
    } else {
      setError(data.error || 'Signup failed')
    }
  }

  if (success) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="max-w-md w-full p-6 bg-white rounded-lg shadow">
          <h1 className="text-2xl font-bold mb-4">Check Your Email</h1>
          <p>We sent a verification link to {email}. Click the link to activate your account.</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex items-center justify-center">
      <form onSubmit={handleSubmit} className="max-w-md w-full p-6 bg-white rounded-lg shadow">
        <h1 className="text-2xl font-bold mb-6">Sign Up</h1>

        {error && <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">{error}</div>}

        <div className="mb-4">
          <label className="block mb-2">Email</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="w-full p-2 border rounded"
            required
          />
        </div>

        <div className="mb-6">
          <label className="block mb-2">Password</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full p-2 border rounded"
            required
            minLength={6}
          />
        </div>

        <button type="submit" className="w-full bg-blue-600 text-white p-2 rounded hover:bg-blue-700">
          Sign Up
        </button>

        <p className="mt-4 text-center">
          Already have an account? <a href="/login" className="text-blue-600">Log in</a>
        </p>
      </form>
    </div>
  )
}
```

**Step 5: Create login page** (similar form with signInWithPassword):
```typescript
// src/app/(auth)/login/page.tsx
'use client'

import { useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useRouter } from 'next/navigation'

export default function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')
  const router = useRouter()
  const supabase = createClient()

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    setError('')

    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) {
      setError(error.message)
    } else {
      router.push('/dashboard')
      router.refresh()
    }
  }

  async function handleLogout() {
    await supabase.auth.signOut()
    router.refresh()
  }

  return (
    <div className="min-h-screen flex items-center justify-center">
      <form onSubmit={handleSubmit} className="max-w-md w-full p-6 bg-white rounded-lg shadow">
        <h1 className="text-2xl font-bold mb-6">Log In</h1>

        {error && <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">{error}</div>}

        <div className="mb-4">
          <label className="block mb-2">Email</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="w-full p-2 border rounded"
            required
          />
        </div>

        <div className="mb-6">
          <label className="block mb-2">Password</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full p-2 border rounded"
            required
          />
        </div>

        <button type="submit" className="w-full bg-blue-600 text-white p-2 rounded hover:bg-blue-700">
          Log In
        </button>

        <p className="mt-4 text-center">
          Don't have an account? <a href="/signup" className="text-blue-600">Sign up</a>
        </p>
      </form>
    </div>
  )
}
```

Configure Supabase email templates in dashboard (Settings > Auth > Email Templates) to use verification flow.
  </action>
  <verify>
Test authentication flow:
1. Start dev server: `npm run dev`
2. Visit http://localhost:3000/signup
3. Enter test email and password
4. Check Supabase dashboard Logs for verification email sent
5. Copy verification link from logs (or check email if using real address)
6. Open verification link - should redirect to /dashboard
7. Check credit_transactions table - should have 3 signup_bonus credits
8. Test login at http://localhost:3000/login with same credentials
9. Verify session persists on page refresh
  </verify>
  <done>
- Middleware refreshes auth tokens on every request using getClaims()
- Signup flow creates user and sends verification email
- Email verification callback allocates 3 free credits
- Login flow establishes session with Supabase
- Session persists across browser refresh
- Protected routes redirect to login when unauthenticated
- Forms have basic styling and error handling
  </done>
</task>

</tasks>

<verification>
End-to-end authentication verification:

1. **Signup works:** User can create account at /signup, receives email
2. **Email verification:** Clicking link verifies email and redirects to dashboard
3. **Credits allocated:** 3 signup_bonus credits appear in credit_transactions table
4. **Login works:** User can log in at /login with verified credentials
5. **Session persists:** Refresh browser, session remains active
6. **Logout works:** User can sign out and session terminates
7. **Route protection:** Accessing /dashboard without auth redirects to /login
</verification>

<success_criteria>
- Complete signup, email verification, login, logout flow functional
- Supabase auth integrated using @supabase/ssr (not deprecated packages)
- Middleware uses getClaims() for token validation (not getSession())
- Session cookies managed automatically by middleware
- 3 free credits allocated on email verification
- Protected routes redirect unauthenticated users
- No TypeScript or runtime errors in auth flow
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
